Intersect 2.5 - Documentation
How-To Guide

Table Of Contents
* Build.py
* Intersect.py
* Droppers




						[ Build.py Application ]

The Build application can be used to quickly generate Intersect server-side shells. You need to specify an IP address,
port number, script name and shell type. Build.py will copy the server-side template you pick into the Scripts directory
and then add the options you entered. Remember that if you choose a XOR shell, you must also specify a XOR private key.
If you don't the information will be left blank and defeats the entire purpose of using XOR to begin with.

Since Build.py is executed purely from the command line, it can be easily called from other applications or scripts that
you might write. The help menu is displayed below.

user@system (Intersect)# ./build.py -h
usage: build.py [-h] --address ADDRESS --port PORT --type
                {tcpbind,tcprev,xorbind,xorrev} --name NAME [--key KEY]

Quickly create an Intersect server-side shell. Specify the shell type, host
and port information and a name for your new shell.

optional arguments:
  -h, --help            show this help message and exit
  --address ADDRESS     IP address for listen or bind shell
  --port PORT           Port for listen or bind shell.
  --type {tcpbind,tcprev,xorbind,xorrev}
                        Type of shell.
  --name NAME           Filename new shell will be saved as.
  --key KEY             XOR private key

To create a bind shell script, for example, you would run the following command:
./build.py --address 192.168.1.4 --port 4444 --type tcpbind --name my-new-shell

The process will only take a few seconds and then 'my-new-shell' will be placed into the Scripts directory and is ready
to be executed on your targets system.





						[ Intersect main application ]


* Main menu
* Interacting with target systems
* Downloaded files and logs

Main Menu:

Intersect.py is the main application within the Intersect framework. When you execute the script, you will be presented
with an interactive console where you can build new server-side shells, interact with targets and start shell listeners.

Intersect help menu:
    :active  =>  list active Intersect sessions
     :about  =>  display the 'about' dialog
     :clear  =>  clears the screen
    :client  =>  start a new client
     :build  =>  build a new server-side shell
      :help  =>  show this help menu
  :listener  =>  start a new listener
  :interact  =>  interact with an active session
      :exit  =>  exit Intersect completely


The :build command can be used to create a server-side script, just like the build.py script, except it is done
interactively through the console. You will be prompted for a script name and host/port information. Once the script
is built, it will be saved to the Scripts folder. This option is included so you can generate server scripts and then
interact with them without having to leave the Intersect console.

At the time of writing this, the :interact command does not work. The idea behind it is that while in a shell session,
you can use the :background command to keep your shell open and return to the Intersect main menu. While the :background
command *does* work and will send your session to the background, there is currently no way to interact with your shell
once you do this. I am working on a fix for this problem and it's on the very top of my To-Do list.

The :active command will show you a list of shell sessions that have been sent to the background, displaying their
session name and the host/port information.



Interacting with target systems:

Once you build and execute your shell on the target system, you can interact with the system by using the :client or
:listener commands. Choose the appropriate option whether you are using a bind or reverse shell.
You will be asked to give your shell session a name which will be used to identify that system for logging purposes
and tagging any files you download from the target system.

All files downloaded, whether through the use of the :download command or by executing modules, will be saved into the
Storage folder. The files will be prepended with your session name. For example, if you download the file 'passwords.txt'
from a session named 'office', it will be saved as 'Storage/office-passwords.txt'.

The session name is also used for the ActivityLog file that is kept in the Logs folder. A log entry is created any time
you start a new shell connection, download or upload a file and execute a module on the target. This is done so when you
are preparing your documentation or just looking for information, you can just grep the ActivityLog file for your desired
session name and view all the actions that took place.

This new release of Intersect uses an entirely new method for executing modules and gathering information, as opposed to
the previous versions. All of the modules are stored on the attackers system and sent to the target only when called
upon. To view an available list of modules, type :mods or execute modules by using the :exec command from a shell session.
When you execute a module, the local file is read, encoded with base64 and sent to the target. The target system will
decode the module, read the commands in memory, execute and pipe the information back to the attacker.

This way there is no need for any modules to be stored on the targets file system and any module can be called remotely.
In the older versions of Intersect, any files would be gathered to the temporary directory and saved there until you
manually downloaded them. Now, all the files are downloaded directly back to your system just by running the module.

Again, all files and information that is downloaded by running a module will either be displayed on screen or saved to
the Storage directory, prepended by the session name. You can view a list of all downloaded files for your session by
using the :files command.

Shell session help menu:
    :background  =>  send this shell to the background
          :mods  =>  show available modules
   :info module  =>  display module information
 :download file  =>  download file from host
   :upload file  =>  upload file to host
   :exec module  =>  sends script to host and executes
         :files  =>  display contents of your files directory
        :killme  =>  shuts down server completely
          :quit  =>  closes shell connection




                                       [ Droppers ]

Content coming soon...
